import serial
import struct
import sys
import numpy as np
from random import *

import tensorflow as tf

def perso_model_prediction(model, input_values, summary=False):
    # Load an already existing model and test its outputs
    to_be_tested_model = tf.keras.models.load_model(model)

    if summary == True:
        to_be_tested_model.summary()
        for layers in to_be_tested_model.layers:
            print(layers.kernel)

    output_pred = to_be_tested_model.predict(input_values)
    return output_pred

class MNIST_set:
    def __init__(self, used_model):
        self.used_model = used_model

        self.x_sample = -1
        self.y_sample = -1

        self.received_output = np.zeros((1, 10))
        # self.received_categories = np.zeros((3))

    def set_dataset_from_xtest(self, path_xtest, path_ytest):
        self.X_test = np.load(path_xtest).astype(dtype=np.float32)
        self.Y_test = np.load(path_ytest).astype(dtype=np.float32)

    def pick_rand_value_from_xtest(self):
        rand_sample = randint(0, self.X_test.shape[0] - 1)
        self.x_sample = self.X_test[rand_sample]
        self.y_sample = self.Y_test[rand_sample]
        tmp = self.y_sample.argmax(axis=0)
        print("Chosen input's corresponding label is " + str(tmp) + " according to y_test")

    def get_prediction(self):
        print(self.x_sample.shape)
        tmp_proba = perso_model_prediction(self.used_model, self.x_sample)
        self.y_proba = tmp_proba
        tmp = self.y_proba.argmax(axis=0)
        print("\nPYTHON:")
        print("Model prediction is " + str(tmp) + " with probability " + str(self.y_proba[tmp]))

    def categorize_received_output(self):
        print("STM32:")
        print("Obtained probabilities: \n" + str(self.received_output.round(decimals=4)))
        index = self.received_output.argmax(axis=1)
        print("Model prediction is " + str(index) + " with probability " + str(self.received_output[0][index]) + "\n")

        if (self.y_sample.argmax(axis=0) != index):
            print("***** Prediction does not match with y_test label")
        else:
            print("***** Prediction matches with y_test label")

    def match_pred_label(self):
        if (self.y_sample.argmax(axis=0) != self.received_output.argmax(axis=1)):
            return 1
        else:
            return 0


def send_NN_inputs_to_STM32(mnist_set, ser):
    if not ser.isOpen():
        print ("Error: serial connection to be used isn't opened")
        sys.exit(-1)

    # Synchronisation loop
    # synchronisation_with_target()

    # Send inputs to the Neural Network
    input_sent = False
    ser.flush()

    tmp = mnist_set.x_sample.reshape((28,28))
    while(input_sent == False):

        for i in range(28):
            for j in range(28):
                ser.write(tmp[i,j])

        input_sent = True

    # Used for debug (i.e. get the picture sent)
    #for i in range(28):
    #    for j in range(28):
    #        tmp[i][j] = struct.unpack('f', ser.read(4))[0]
    #plt.imshow(tmp, cmap='gray')
    #plt.show()

    # wait for the output values generated by the STM32
    out_ack = b"000"
    while(out_ack != b"010"): # "010" has been chosen arbitrarily
        out_ack = ser.read(3)

    for i in range(10):
        mnist_set.received_output[0][i] = struct.unpack('f', ser.read(4))[0]

    mnist_set.categorize_received_output()



ser = serial.Serial(port="COM12", baudrate=115200, timeout=1)
ser.close()
ser.open()

# ser.write("")
x = ser.read(3)
print(x)

ser.close()

